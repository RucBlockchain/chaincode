package main


import (
	"fmt"
	"bytes"
	"math"
	"strconv"
	"encoding/json"

	"github.com/hyperledger/fabric/core/chaincode/shim"
	pb "github.com/hyperledger/fabric/protos/peer"
)


const MIN = 0.001


// SimpleChaincode example simple Chaincode implementation
type SimpleChaincode struct {
}


// =====================================
//      Init initializes chaincode
// =====================================
func (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface) pb.Response {
	return shim.Success(nil)
}


type request struct {
	Id             string  `json:"id"`
	ObjectType     string  `json:"objectType"`    //objectType is used to distinguish the various types of objects in state database
	Requester      string  `json:"requester"`
	Task           string  `json:"task"`
	ResponseTime   float64 `json:"responseTime"`
	Throughput     float64 `json:"throughput"`
	Budget         float64 `json:"budget"`
}


type response struct {
	ReqId          string  `json:"reqid"`
	ObjectType     string  `json:"objectType"`    //objectType is used to distinguish the various types of objects in state database
	Requester      string  `json:"requester"`
	Provider       string  `json:"provider"`
	Task           string  `json:"task"`
	ResponseTime   float64 `json:"responseTime"`
	Throughput     float64 `json:"throughput"`
	Price          float64 `json:"price"`
}


type agreement struct {
	Requester      string    `json:"requester"`
	Task           string    `json:"task"`
	Provider       string    `json:"provider"`
	ResponseTime   float64   `json:"responseTime"`
	Throughput     float64   `json:"throughput"`
	FinalPrice     float64   `json:"finalPrice"`
}


// ===================================================================================
// Main
// ===================================================================================
func main() {
	err := shim.Start(new(SimpleChaincode))
	if err != nil {
		fmt.Printf("Error starting Simple chaincode: %s", err)
	}
}


// =====================================================
//      Invoke - Our entry point for Invocations
// =====================================================
func (t *SimpleChaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response {
	function, args := stub.GetFunctionAndParameters()
	fmt.Println("invoke is running " + function)

	if function == "writeRequest" {
		return t.writeRequest(stub, args)
	} else if function == "readRequest" {
		return t.readRequest(stub, args)
	} else if function == "writeResponse" {
		return t.writeResponse(stub, args)
	} else if function == "readResponse" {
		return t.readResponse(stub, args)
	} else if function == "check" {
		return t.check(stub, args)
	} else if function == "queryByObjectType" {
    return t.queryByObjectType(stub, args)
  } else if function == "writeRequestArray" {
    return t.writeRequestArray(stub, args)
  }
	return shim.Success(nil)
}


// ==============================================================
//       writeRequest - write request from chaincode state
// ==============================================================
func (t *SimpleChaincode) writeRequest(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	var err error

	//   0    1           2          3      4       5
	//   1, "u1", "collect_data", "0.31", "6.9", "12.7"
	if len(args) != 6 {
		return shim.Error("Incorrect number of arguments. Expecting 6")
	}

	// ==== Input sanitation ====
	fmt.Println("- start write request")
	if len(args[0]) <= 0 {
		return shim.Error("1st argument must be a non-empty string")
	}
	if len(args[1]) <= 0 {
		return shim.Error("2nd argument must be a non-empty string")
	}
	if len(args[2]) <= 0 {
		return shim.Error("3rd argument must be a non-empty string")
	}
	if len(args[3]) <= 0 {
		return shim.Error("4th argument must be a non-empty string")
	}
	if len(args[4]) <= 0 {
		return shim.Error("5th argument must be a non-empty string")
	}
	if len(args[5]) <= 0 {
		return shim.Error("6th argument must be a non-empty string")
	}

	id := args[0]
	auctioneer := args[1]
  task := args[2]

	responseTime, err := strconv.ParseFloat(args[3], 64)
	if err != nil {
		return shim.Error("2rd argument must be a numeric string")
	}

	throughput, err := strconv.ParseFloat(args[4], 64)
	if err != nil {
		return shim.Error("3rd argument must be a numeric string")
	}

	budget, err := strconv.ParseFloat(args[5], 64)
	if err != nil {
		return shim.Error("4rd argument must be a numeric string")
	}
	objectType := "request"

	// ==== Create Compositekey ====
	indexName := "index"
	IndexKey, err := stub.CreateCompositeKey(indexName, []string{id, auctioneer, task})
	if err != nil {
		return shim.Error(err.Error())
	}
	value := []byte{0x00}

	// ==== Check if request already exists ====
	requestAsBytes, err := stub.GetState(IndexKey)
	if err != nil {
		return shim.Error("Failed to get request: " + err.Error())
	} else if requestAsBytes != nil {
		fmt.Println("The request already exists")
		return shim.Error("The request already exists")
	}
	stub.PutState(IndexKey, value)

	// ==== Create request object and marshal to JSON ====
	requestJSON := &request{id, objectType, auctioneer, task, responseTime, throughput, budget}
	requestJSONasBytes, err := json.Marshal(requestJSON)
	if err != nil {
		return shim.Error(err.Error())
	}

	// === Save request to state ===
	err = stub.PutState(IndexKey, requestJSONasBytes)
	if err != nil {
		return shim.Error(err.Error())
	}

	fmt.Println("write request successfully", auctioneer)
  fmt.Println("- end write request\n")
	return shim.Success(nil)
}


// =============================================================================
//      writeRequestArray - write all requests to chaincode state together
// =============================================================================
func (t *SimpleChaincode) writeRequestArray(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	var i int

	//  0           2          3     4      5       6      7       8
	//"u1", "collect_data", "0.5", "1.9", "7.3", "0.31", "6.9", "12.7"

	judge := (len(args) - 2)%3
	if judge != 0 {
		return shim.Error("Incorrect number of arguments.")
	}

	fmt.Println("- start write requestArray")
	requester := args[0]
	task := args[1]
	objectType := "request"

	queryString := fmt.Sprintf("{\"selector\":{\"objectType\":\"%s\"}}", objectType)
	id, err := getCountOfRequests(stub, queryString)

	if err != nil {
		return shim.Error("Fail to get the counts of requests.")
	}

	for i = 2; i < len(args); i = i + 3 {
		id = id + 1
		idNum := strconv.Itoa(id)
		responseTime, err := strconv.ParseFloat(args[i], 64)
		if err != nil {
			return shim.Error("Argument must be a numeric string")
		}
		throughput, err := strconv.ParseFloat(args[i+1], 64)
		if err != nil {
			return shim.Error("Argument must be a numeric string")
		}
		budget, err := strconv.ParseFloat(args[i+2], 64)
		if err != nil {
			return shim.Error("Argument must be a numeric string")
		}

		// ==== Create Compositekey ====
		indexName := "index"
		IndexKey, err := stub.CreateCompositeKey(indexName, []string{idNum, requester, task})
		if err != nil {
			return shim.Error(err.Error())
		}
		value := []byte{0x00}

		// ==== Check if request already exists ====
		requestAsBytes, err := stub.GetState(IndexKey)
		if err != nil {
			return shim.Error("Failed to get request: " + err.Error())
		} else if requestAsBytes != nil {
			fmt.Println("The request already exists")
			return shim.Error("The request already exists")
		}
		stub.PutState(IndexKey, value)

		// ==== Create request object and marshal to JSON ====
		requestJSON := &request{idNum, objectType, requester, task, responseTime, throughput, budget}
		requestJSONasBytes, err := json.Marshal(requestJSON)
		if err != nil {
			return shim.Error(err.Error())
		}

		// === Save request to state ===
		err = stub.PutState(IndexKey, requestJSONasBytes)
		if err != nil {
			return shim.Error(err.Error())
		}
	}

	fmt.Println("write requestArray successfully", requester)
  fmt.Println("- end write requestArray\n")
	return shim.Success(nil)
}


// =============================================================
//       readRequest - read request from chaincode state
// =============================================================
func (t *SimpleChaincode) readRequest(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	var jsonResp string

	//0    1           2
	//1, "u1", "collect_data"
	if len(args) != 3 {
		return shim.Error("Incorrect number of arguments. Expecting 3")
	}

	fmt.Println("- start read request")
	if len(args[0]) <= 0 {
		return shim.Error("1st argument must be a non-empty string")
	}
	if len(args[1]) <= 0 {
		return shim.Error("2nd argument must be a non-empty string")
	}
	if len(args[2]) <= 0 {
		return shim.Error("3rd argument must be a non-empty string")
	}

	id := args[0]
	requester := args[1]
	task := args[2]

	// ==== Create Compositekey ====
	indexName := "index"
	IndexKey, err := stub.CreateCompositeKey(indexName, []string{id, requester, task})
	if err != nil {
		return shim.Error(err.Error())
	}

	requestAsbytes, err := stub.GetState(IndexKey)    //get the request from chaincode state
	if err != nil {
		jsonResp = "{\"Error\":\"Failed to get state for request\"}"
		return shim.Error(jsonResp)
	} else if requestAsbytes == nil {
		jsonResp = "{\"Error\":\"Agenttask does not exist\"}"
		return shim.Error(jsonResp)
	}

	fmt.Println("readRequestResults:", string(requestAsbytes))
	fmt.Println("- end read request\n")
	return shim.Success(requestAsbytes)
}


// ================================================================
//       writeResponse - write Response from chaincode state
// ================================================================
func (t *SimpleChaincode) writeResponse(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	var err error

	//0    1     2           3          4      5      6
	//1, "u1", "u2", "collect_data", "0.65", "7.5","10.0"
	if len(args) != 7 {
		return shim.Error("Incorrect number of arguments. Expecting 7")
	}

	// ==== Input sanitation ====
	fmt.Println("- start write response")
	if len(args[0]) <= 0 {
		return shim.Error("1st argument must be a non-empty string")
	}
	if len(args[1]) <= 0 {
		return shim.Error("2nd argument must be a non-empty string")
	}
	if len(args[2]) <= 0 {
		return shim.Error("3rd argument must be a non-empty string")
	}
	if len(args[3]) <= 0 {
		return shim.Error("4th argument must be a non-empty string")
	}
	if len(args[4]) <= 0 {
		return shim.Error("5th argument must be a non-empty string")
	}
	if len(args[5]) <= 0 {
		return shim.Error("6th argument must be a non-empty string")
	}
	if len(args[6]) <= 0 {
		return shim.Error("7th argument must be a non-empty string")
	}

	reqid := args[0]
	requester := args[1]
	provider := args[2]
  task := args[3]

	responseTime, err := strconv.ParseFloat(args[4], 64)
	if err != nil {
		return shim.Error("5th argument must be a numeric string")
	}

	throughput, err := strconv.ParseFloat(args[5], 64)
	if err != nil {
		return shim.Error("6th argument must be a numeric string")
	}

	price, err := strconv.ParseFloat(args[6], 64)
	if err != nil {
		return shim.Error("7th argument must be a numeric string")
	}

	objectType := "response"

	// ==== create CreateCompositeKey ====
	indexName := "index"
	IndexKey, err := stub.CreateCompositeKey(indexName, []string{reqid, requester, provider, task})
	if err != nil {
		return shim.Error(err.Error())
	}
	value := []byte{0x00}

	// ==== Check if response already exists ====
	provideAsBytes, err := stub.GetState(IndexKey)
	if err != nil {
		return shim.Error("Failed to get provide: " + err.Error())
	} else if provideAsBytes != nil {
		fmt.Println("The response already exists")
		return shim.Error("The response already exists")
	}
	stub.PutState(IndexKey, value)

	// ==== Create response object and marshal to JSON ====
	provideJSON := &response{reqid, objectType, requester, provider, task, responseTime, throughput, price}
	provideJSONasBytes, err := json.Marshal(provideJSON)
	if err != nil {
		return shim.Error(err.Error())
	}

	// ==== Save response to state ====
	err = stub.PutState(IndexKey, provideJSONasBytes)
	if err != nil {
		return shim.Error(err.Error())
	}

	fmt.Println("write response successfully", provider)
  fmt.Println("- end write response\n")
	return shim.Success(nil)
}


// =============================================================
//       readResponse - read response from chaincode state
// =============================================================
func (t *SimpleChaincode) readResponse(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	var jsonResp string

	// 0    1     2           3
	// 1, "u1", "u2", "collect_data"
	if len(args) != 4 {
		return shim.Error("Incorrect number of arguments. Expecting 4")
	}

	// ==== Input sanitation ====
	fmt.Println("- start read response")
	if len(args[0]) <= 0 {
		return shim.Error("1st argument must be a non-empty string")
	}
	if len(args[1]) <= 0 {
		return shim.Error("2nd argument must be a non-empty string")
	}
	if len(args[2]) <= 0 {
		return shim.Error("3rd argument must be a non-empty string")
	}
	if len(args[3]) <= 0 {
		return shim.Error("4th argument must be a non-empty string")
	}

	// ==== Create CreateCompositeKey ====
	indexName := "index"
	IndexKey, err := stub.CreateCompositeKey(indexName, []string{args[0], args[1], args[2], args[3]})
	if err != nil {
		return shim.Error(err.Error())
	}

	// ==== Check if response exists ====
	responseAsbytes, err := stub.GetState(IndexKey)
	if err != nil {
		jsonResp = "{\"Error\":\"Failed to get state for response\"}"
		return shim.Error(jsonResp)
	} else if responseAsbytes == nil {
		jsonResp = "{\"Error\":\"(Response does not exist\"}"
		return shim.Error(jsonResp)
	}

	fmt.Println("readResponseResults:",string(responseAsbytes))
	fmt.Println("- end read response\n")
	return shim.Success(responseAsbytes)
}


// ========================================================================================
//     queryByObjectType - query all requests or all responses from chaincode state
// ========================================================================================
func (t *SimpleChaincode) queryByObjectType(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	//    1
	//"request"
	if len(args) < 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}

	objectType := args[0]

	queryString := fmt.Sprintf("{\"selector\":{\"objectType\":\"%s\"}}", objectType)
	queryResults, err := getResultForQueryString(stub, queryString)

	if err != nil {
		return shim.Error(err.Error())
	}
	return shim.Success(queryResults)
}


// ===================================================================
//        Check - check responses that meet all requirements
// ===================================================================
func (t *SimpleChaincode) check(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	requestArray := make([]request, 0)
	responseArray := make([]response, 0)
	var requ request
	var requestErr error
	var responseErr error
	var i, j, k int
	var maxQoS float64 = 0
	var secondLowPrice, leastPrice float64
	var maxId,minId string
	var aPrice float64

	var satResponseMap map[string][]response
	satResponseMap = make(map[string][]response)  //init satResponseMap

	fmt.Println("- start check")

	// ==== Check all requests ====
	queryRequestString := fmt.Sprintf("{\"selector\":{\"objectType\":\"request\"}}")
	fmt.Println("queryString:", queryRequestString)
	requestArray, requestErr = getArrayForRequest(stub, queryRequestString)
	if requestErr != nil {
		return shim.Error(requestErr.Error())
	}

	// ==== Check all responses ====
	queryResponseString := fmt.Sprintf("{\"selector\":{\"objectType\":\"response\"}}")
	fmt.Println("queryString:", queryResponseString)
	responseArray, responseErr = getArrayForResponse(stub, queryResponseString)
	if responseErr != nil {
		return shim.Error(responseErr.Error())
	}

	// ==== Check satisfactory responses ====
	for i = 0; i < len(requestArray); i++ {
		satResponseArray := make([]response, 0)
		req := requestArray[i]
		reqid := req.Id
		for j = 0; j < len(responseArray); j++ {
			res := responseArray[j]
			resid := res.ReqId

			condition1 := (reqid == resid)
			condition2 := math.Max(req.ResponseTime, res.ResponseTime) == req.ResponseTime && math.Abs(req.ResponseTime - res.ResponseTime) > MIN
			condition3 := math.Max(req.Throughput, res.Throughput) == res.Throughput && math.Abs(res.Throughput - req.Throughput) > MIN
			condition4 := math.Max(req.Budget, res.Price) == req.Budget && math.Abs(req.Budget - res.Price) > MIN

			if condition1 && condition2 && condition3 && condition4 {
				satResponseArray = append(satResponseArray, res)
			}
		}
		satResponseMap[reqid] = satResponseArray
	}

	//==== check results of requests ====
	for key, value := range satResponseMap {
		//fmt.Printf("keys:%s, value:%v\n", key, value)

		keyInt, err := strconv.Atoi(key)
		if err != nil {
			return shim.Error("Argument must be a numeric string")
		}
		if value != nil {

			requ = requestArray[keyInt-1]
			QoS := requ.ResponseTime + requ.Throughput
			if maxQoS < QoS {
				maxQoS = QoS
				maxId = requ.Id
			}
		}
	}

	satRes := satResponseMap[maxId]

	if len(satRes) == 1 {
		leastPrice = satRes[0].Price
		minId = strconv.Itoa(0)
		aPrice = leastPrice
	} else {
		if satRes[0].Price < satRes[1].Price {
			leastPrice = satRes[0].Price
			secondLowPrice = satRes[1].Price
			minId = strconv.Itoa(0)
		} else {
			leastPrice = satRes[1].Price
			secondLowPrice = satRes[0].Price
			minId = strconv.Itoa(1)
		}
		for k = 2; k < len(satRes); k++ {
			if satRes[k].Price <= leastPrice {
				temp := leastPrice
				leastPrice = satRes[k].Price
				secondLowPrice = temp
				minId = strconv.Itoa(k)
			} else if satRes[k].Price > leastPrice && satRes[k].Price <= secondLowPrice {
				secondLowPrice = satRes[k].Price
			}
		}
		aPrice = secondLowPrice
	}

	minIdInt,err := strconv.Atoi(minId)
	if err != nil {
		return shim.Error("Argument must be a numeric string")
	}

	resp := responseArray[minIdInt]

	aRequester := requ.Requester
	aTask := requ.Task
	aProvider := resp.Provider
	aResponseTime := resp.ResponseTime
	aThroughput := resp.Throughput

	indexName := "index"
	IndexKey, err := stub.CreateCompositeKey(indexName, []string{aRequester, aTask, aProvider})
	if err != nil {
		return shim.Error(err.Error())
	}
	value := []byte{0x00}

	agreementAsBytes, err := stub.GetState(IndexKey)
	if err != nil {
		return shim.Error("Failed to get agreement: " + err.Error())
	} else if agreementAsBytes != nil {
		fmt.Println("The response already exists")
		return shim.Error("The agreement already exists")
	}
	stub.PutState(IndexKey, value)

	agreementJSON := &agreement{aRequester, aTask, aProvider, aResponseTime, aThroughput, aPrice}
	agreementJSONasBytes, err := json.Marshal(agreementJSON)
	if err != nil {
		return shim.Error(err.Error())
	}

	// === Save request to state ===
	err = stub.PutState(IndexKey, agreementJSONasBytes)
	if err != nil {
		return shim.Error(err.Error())
	}

	fmt.Println("- end check\n")
	return shim.Success(agreementJSONasBytes)
}


// =========================================================================================
// getQueryResultForQueryString executes the passed in query string.
// Result set is built and returned as a byte array containing the JSON results.
// =========================================================================================
func getResultForQueryString(stub shim.ChaincodeStubInterface, queryString string) ([]byte, error) {

	resultsIterator, err := stub.GetQueryResult(queryString)
	if err != nil {
		return nil, err
	}
	defer resultsIterator.Close()

	// buffer is a JSON array containing QueryRecords
	var buffer bytes.Buffer
	buffer.WriteString("[")

	providerAlreadyWritten := false
	for resultsIterator.HasNext() {
		queryResponse, err := resultsIterator.Next()
		if err != nil {
			return nil, err
		}
		// Add a comma before array members, suppress it for the first array member
		if providerAlreadyWritten == true {
			buffer.WriteString(",")
		}
		buffer.WriteString("{\"Key\":")
		buffer.WriteString("\"")
		buffer.WriteString(queryResponse.Key)
		buffer.WriteString("\"")

		buffer.WriteString(", \"Record\":")
		// Record is a JSON object, so we write as-is
		buffer.WriteString(string(queryResponse.Value))
		buffer.WriteString("}")
		providerAlreadyWritten = true
	}
	buffer.WriteString("]")

	fmt.Printf("- getResultForQueryString queryResult:\n%s\n", buffer.String())
	return buffer.Bytes(), nil
}


// =========================================================================================
// getArrayForQueryString executes the passed in query string.
// Result set is built and returned as a request array containing the JSON results.
// =========================================================================================
func getArrayForRequest(stub shim.ChaincodeStubInterface, queryString string) ([]request, error) {
	var req request
	reqArray := make([]request, 0)

	resultsIterator, err := stub.GetQueryResult(queryString)
	if err != nil {
		return reqArray, err
	}
	defer resultsIterator.Close()

	fmt.Println("requestArray:" )
	for resultsIterator.HasNext() {
		queryRequest, err := resultsIterator.Next()
		if err != nil {
			return reqArray, err
		}

		errResult := json.Unmarshal([]byte(queryRequest.Value), &req)
		if errResult != nil {
			return reqArray, errResult
		}

		reqArray = append(reqArray, req)
		fmt.Println(string(queryRequest.Value))
	}
	return reqArray, nil
}


// =========================================================================================
// getArrayForQueryString executes the passed in query string.
// Result set is built and returned as a response array containing the JSON results.
// =========================================================================================
func getArrayForResponse(stub shim.ChaincodeStubInterface, queryString string) ([]response, error) {
	var res response
	resArray := make([]response, 0)

	resultsIterator, err := stub.GetQueryResult(queryString)
	if err != nil {
		return resArray, err
	}
	defer resultsIterator.Close()

	fmt.Println("responseArray:" )
	for resultsIterator.HasNext() {
		queryResponse, err := resultsIterator.Next()
		if err != nil {
			return resArray, err
		}

		errResult := json.Unmarshal([]byte(queryResponse.Value), &res)
		if errResult != nil {
			//jsonResp := "{\"Error\":\"Failed to decode JSON of Key: " + queryResponse.Key + "\"}"
			return resArray, errResult
		}

		resArray = append(resArray, res)
		fmt.Println(string(queryResponse.Value))
	}
	return resArray, nil
}


// =========================================================================================
// getCountOfRequests- Calculate the counts of requests that requester has already written
// =========================================================================================
func getCountOfRequests(stub shim.ChaincodeStubInterface, queryString string) (int, error) {
	var sum int = 0

	idIterator, err := stub.GetQueryResult(queryString)
	if err != nil {
		return sum, err
	}
	defer idIterator.Close()

	for idIterator.HasNext() {
		_, err := idIterator.Next()
		if err != nil {
			return sum, err
		}
		sum = sum + 1
	}

	return sum, nil
}
